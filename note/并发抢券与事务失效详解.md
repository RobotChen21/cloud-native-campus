# 学习笔记：并发抢券、乐观锁与事务失效详解

## 1. 乐观锁解决超卖问题

在优惠券秒杀场景中，最核心的问题之一是**超卖**（Coupon Over-selling），即卖出的券数量超过了设定的总库存。

### 问题场景
假设库存剩 1 张，两个线程同时查询到 `totalNum > 0`，然后分别执行扣减操作，导致库存变为 -1。

### 解决方案：CAS 思想（乐观锁）
不需要加分布式锁，利用数据库本身的行锁特性，在 SQL 语句中加入条件判断。

**核心逻辑：**
> "只要库存足够，就允许扣减。"

**SQL 实现：**
```sql
UPDATE coupon 
SET issue_num = issue_num + 1 
WHERE id = #{couponId} 
  AND issue_num < total_num -- 关键条件：乐观锁判断
```
只要这条 SQL 更新受影响行数为 1，说明扣减成功；如果为 0，说明库存不足，扣减失败。

---

## 2. 单用户并发抢券与锁的粒度

除了超卖，还需要限制**同一个用户重复领取**（例如每人限领 1 张）。

### 问题分析
如果用户开启脚本并发请求：
1.  线程 A 查询：用户未领取。
2.  线程 B 查询：用户未领取。
3.  线程 A 插入领取记录。
4.  线程 B 插入领取记录。
**结果**：用户领了两张券，违反规则。

### 初步方案：加锁
必须对“查询 + 插入”这段逻辑加锁，且锁的粒度要是 **User ID**（只锁当前用户，不影响其他用户）。

```java
synchronized(userId.toString().intern()) {
    // 1. 查询是否已领
    // 2. 扣减库存
    // 3. 插入记录
}
```

### 💣 经典并发陷阱：事务与锁的顺序
如果上述代码在 `@Transactional` 方法内部：
1.  **执行顺序**：`事务开启` -> `加锁` -> `执行业务` -> `释放锁` -> `事务提交`。
2.  **Bug 复现**：
    *   线程 A 执行完业务，**释放锁**。
    *   线程 A 的事务**尚未提交**（数据库中数据未通过 Commit 写入，其他事务不可见）。
    *   线程 B 拿到锁，进入执行。
    *   线程 B 查询数据库，由于 A 未提交（且隔离级别通常是 RC 读已提交），B 读不到 A 的记录。
    *   线程 B 也插入记录。
    *   **结果**：限制失效。

### ✅ 正确方案
**原则**：锁的范围必须 **大于** 事务的范围。即：**先上锁，再开事务**。

```java
// Controller 层或上层业务
synchronized(userId.toString().intern()) {
   // 调用事务方法
   userCouponService.checkAndCreateUserCoupon(uid, couponId);
}
```

---

## 3. 事务失效的常见场景

在 Spring 开发中，`@Transactional` 可能会因为使用不当而失效。以下是 6 种常见情况：

1.  **访问权限修饰符不是 `public`**
    *   Spring AOP 默认只代理 public 方法。
2.  **方法内部调用（同类调用 / Self-Invocation）** 
    *   **当前遇到的场景**。详情见下文。
3.  **异常被 `try-catch` 捕获吃掉**
    *   事务切面捕获不到异常，认为执行成功，从而提交事务。
4.  **回滚异常类型不匹配**
    *   `@Transactional` 默认只回滚 `RuntimeException` 和 `Error`。
    *   如果抛出 Checked Exception（如 `Exception`），事务不会回滚。
    *   **修复**：`@Transactional(rollbackFor = Exception.class)`。
5.  **事务传播行为配置错误**
    *   例如使用了 `PROPAGATION_NOT_SUPPORTED`（以非事务方式运行）。
6.  **Bean 没有被 Spring 管理**
    *   直接 `new` 出来的对象，或者没有加 `@Service` / `@Component` 注解。

---

## 4. 详解：同类调用导致事务失效与解决方案

### 场景描述
在 `UserCouponServiceImpl` 类中，假设有一个非事务方法 `a()`，它调用了本类中的事务方法 `b()`：

```java
public void a() {
    // 检查逻辑...
    this.b(); // 直接调用本类方法
}

@Transactional
public void b() {
    // 数据库操作...
}
```

### 失效原因
Spring 的事务是基于 **AOP（动态代理）** 实现的。
*   当我们注入 `IUserCouponService` 时，拿到的是一个 **代理对象（Proxy）**。
*   外部调用 `proxy.b()` 时，先经过代理逻辑（开启事务），再调用目标对象 `target.b()`。
*   但是，当我们在 `a()` 中执行 `this.b()` 时，`this` 指的是 **目标对象本身（Target）**，而不是代理对象。
*   **结果**：直接运行了 `b()` 的代码，绕过了 AOP 代理，**没有开启事务**。

### 🛠️ 解决方案：AspectJ 暴露代理对象

为了在同类中调用事务方法且使事务生效，必须通过代理对象来调用。

#### 步骤 1: 引入 AspectJ 依赖
确保项目中包含 AspectJ 相关的依赖（Spring Boot Starter AOP 通常已包含）。
```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

#### 步骤 2: 开启代理暴露
在启动类或配置类上添加注解：
```java
@EnableAspectJAutoProxy(exposeProxy = true)
```

#### 步骤 3: 获取代理对象并调用
在代码中使用 `AopContext.currentProxy()` 获取当前的代理对象，并强制转换为接口类型。

```java
public void a() {
    // ... 前置逻辑 ...
    
    // ❌ 错误写法：事务失效
    // this.b(); 

    // ✅ 正确写法：获取代理对象调用
    IUserCouponService proxy = (IUserCouponService) AopContext.currentProxy();
    proxy.b();
}
```

通过这种方式，`b()` 方法的调用会重新经过 AOP 切面，事务逻辑得以正常执行。
