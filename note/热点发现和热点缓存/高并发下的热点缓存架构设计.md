# 📝 笔记：高并发下的热点缓存架构设计

### 一、 核心架构：三步走战略

解决“特大流量”与“普通流量”共存的核心，在于**分级治理**。

1. **发现（侦察）：**
   - **手段：** 实时计算（Flink 分析日志） 或 边缘节点计数（Nginx/网关层粗略采样）。
   - **产出：** 识别出 Top N 的热点 `key`（如 `weiboId_8888`）。
2. **通知（传令）：**
   - **动作：** 配置中心（Nacos/Etcd）将热点 `key` 推送到所有业务服务的**本地内存**（Local Cache Allowlist）。
3. **执行（分流）：**
   - **热点 Key：** 走 JVM 内存 + 逻辑过期（不查 Redis，不等待）。
   - **普通 Key：** 走 Redis + 互斥锁（标准缓存击穿方案）。

------

### 二、 核心代码逻辑（伪代码）

这是业务层（Java）处理请求的**统一入口**，整合了热点特权和普通防御。

Java

```
public WeiboContent getWeibo(String weiboId) {
    String cacheKey = "weibo:" + weiboId;

    // ==========================================
    // 1. 【特权通道】针对被系统判定为“热点”的流量
    // ==========================================
    // 判断依据：本地内存里的一个 Set/Map，由旁路监控系统实时推送
    if (LocalCacheManager.isHotKey(weiboId)) {
        // 动作：直接查 JVM 堆内存（Caffeine/Guava）
        // 没有任何网络开销，也不怕 Redis 挂掉
        WeiboContent obj = LocalCache.get(weiboId);
        
        // 核心：热点数据通常采用“逻辑过期”
        // 如果发现数据逻辑时间过期了，直接返回旧数据（不阻塞），
        // 同时异步启动一个线程去后台更新数据。
        if (obj != null) {
             if (obj.isLogicalExpired()) {
                 asyncThreadUpdate(weiboId); // 异步更新
             }
             return obj; // 无论是否过期，都立刻返回，保证毫秒级响应
        }
        // 如果本地完全没有（刚变成热点），降级去查 Redis/DB 并回填本地
    }

    // ==========================================
    // 2. 【常规通道】针对 99.9% 的普通流量
    // ==========================================
    
    // 2.1 先查 Redis (大部分请求到这里就结束了，速度极快)
    WeiboContent obj = redis.get(cacheKey);
    if (obj != null) {
        return obj;
    }

    // 2.2 【防御阶段】缓存击穿逻辑
    // 只有 Redis 没数据（过期/被驱逐）时，才会执行，防止 DB 被打死
    // 使用互斥锁（Distributed Lock）
    if (lock.tryLock()) {
        try {
            // 双重检查（防止重复查库）
            obj = redis.get(cacheKey);
            if (obj != null) return obj;

            // 查 DB
            obj = db.query(weiboId);
            
            // 回写 Redis (设置 TTL，防止冷数据永久占用)
            // 比如设置 1 小时过期
            redis.set(cacheKey, obj, 3600, TimeUnit.SECONDS); 
        } finally {
            lock.unlock();
        }
    } else {
        // 获取锁失败的线程，稍微睡一下，重试查缓存
        Thread.sleep(50);
        return getWeibo(weiboId);
    }
    
    return obj;
}
```

------

### 三、 关键策略对比

| **特性**         | **普通 Key (常规数据)**                     | **热点 Key (爆款数据)**                                |
| ---------------- | ------------------------------------------- | ------------------------------------------------------ |
| **存储位置**     | Redis 集群                                  | **JVM 本地内存** (Caffeine)                            |
| **缓存失效策略** | **物理过期 (TTL)**   Redis key 真的消失了   | **逻辑过期**   数据永远在，只是字段标记过期            |
| **重建并发控制** | **互斥锁 (Mutex)**   让线程排队，保证一致性 | **不加锁 / 异步重建**   宁可返回旧数据，绝不让用户排队 |
| **适用场景**     | 长尾流量，访问少，哪怕卡顿 200ms 也无所谓   | 瞬时流量极大，网卡/CPU 是瓶颈，必须 0 阻塞             |

------

### 四、 缓存污染防御（针对冷数据）

防止“万年不看的微博”偶然被点击一次后永久占用 Redis 空间。

1. **TTL (必选项)：**
   - 所有普通 Key **必须**设置过期时间（如 1 小时）。
   - *效果：* 即使存了冷数据，1 小时后自动释放。
2. **LRU 淘汰 (兜底项)：**
   - Redis 配置 `maxmemory-policy allkeys-lru`。
   - *效果：* 内存满了，自动踢掉最久没被访问的数据（冷数据先死）。
3. **第二门槛 (进阶项 - 可选)：**
   - *逻辑：* 第一次访问只读库，不写 Redis；第二次访问才写 Redis。
   - *效果：* 彻底拦截爬虫和一次性流量进入 Redis。