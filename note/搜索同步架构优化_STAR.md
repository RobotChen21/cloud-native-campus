# 搜索数据同步架构的极致优化 (CDC + 局部更新) - STAR分析

## Situation (背景与现状)
- **架构选型背景 (Context)**：
    - **为什么 ES 存了全量字段？(宽表模式 vs 纯索引模式)**
        - 为了支持**复杂筛选**（如按价格区间、分类过滤）和**复合排序**（按销量降序），ES 索引必须存储 price, sold, category_id 等业务字段，而不仅仅是 id 和 
ame。
        - 这种**宽表设计**避免了搜索时回源查 MySQL 造成的性能瓶颈（IO Amplification），但同时也带来了**数据强一致性同步**的挑战 —— 任何业务字段变更都必须同步至 ES。
    - **选型防御 (Defense)**：
        - *质疑*：为什么不只存 ID (方案 A)，搜出来再去查 MySQL？
        - *回答*：对于无需排序的简单搜索，方案 A 可行。但本业务强依赖**复合排序**（按价格/热度）和**深分页**。若用方案 A，每次排序都需要回源 MySQL 拉取全量数据到内存，会引发 OOM 和数据库宕机。因此，**宽表模式 (方案 B)** 是 C 端搜索的唯一可行解。
- **业务场景**：在课程发布与管理系统中，运营人员会频繁修改课程信息（如改名、改价、修改描述）。这些变更需要实时同步到 ElasticSearch (ES) 以供用户搜索。
- **原有架构**：采用 **"MQ 通知 + 全量反查覆盖"** 策略。
    - 运营修改课程 -> MySQL 落库 -> 发送只带 `course_id` 的 MQ 消息。
    - 搜索服务监听到 ID -> 调用 Feign 接口回查课程**全量数据** -> 调用 ES `save` 接口进行**文档覆盖 (Upsert)**。
- **面临痛点**：
    1.  **带宽浪费 (IO Amplification)**：课程描述包含大量 HTML 代码（大文档）。仅修改一个价格字段，却导致整个文档在网络和 ES 内部重传、重写，资源损耗极大。
    2.  **并发数据回滚 (Lost Update)**：在运营并发操作场景下（如 A 改名，B 改价），由于 MQ 消费顺序和入库顺序的不确定性，全量覆盖会导致**后到的旧数据覆盖了先到的新数据**，造成数据不一致。
    3.  **代码耦合**：业务 Service 层强耦合了 MQ 发送逻辑，且无法感知具体变更了哪些字段。

## Task (目标与任务)
- **目标**：设计并落地一套 **高性能、低耦合、强一致** 的异构数据同步架构。
- **核心指标**：
    - **解耦**：移除业务代码中的 MQ 发送逻辑。
    - **带宽优化**：实现**字段级**的增量同步，网络传输量降低 80% 以上。
    - **一致性**：彻底解决并发修改导致的数据回滚问题。

## Action (行动与方案决策)
针对上述目标，我深入调研了三种技术方案，并进行了详细的权衡（Trade-off）：

### 方案一：精细化 MQ + 局部更新 (Initial Attempt)
- **思路**：在业务代码中计算字段差异（Diff），发送带变更详情的消息 `{id:1, changes:{"name":"new"}}`。
- **缺点**：虽然解决了带宽问题，但业务代码充斥着大量 `if-else` 对比逻辑，**侵入性太强**，维护成本高。**（放弃）**

### 方案二：版本号乐观锁 (Optimistic Locking)
- **思路**：引入 `version` 字段，写入 ES 时校验 `msg.version > es.version`。
- **缺点**：解决了并发乱序问题，但依然需要全量传输数据，无法解决带宽浪费的大文档痛点。**（仅作为补充手段）**

### 方案三：基于 CDC 思想的应用层模拟 —— **(最终架构选型)**
- **架构决策**：鉴于项目当前处于成长期，引入 Canal/Flink 等组件运维成本过高。我决定采用 **“思想降维”** 策略 —— **在应用层模拟 CDC 行为**。
- **核心实现**：
    1.  **Event Schema 设计**：定义了标准化的变更事件模型，包含 `before/after` 镜像字段，结构完全**对齐 Canal 协议**。
    2.  **AOP 切面拦截**：利用 MyBatis Plus 拦截器（或 Spring AOP）拦截 Service 层的写操作，自动计算字段差异 (Diff) 并生成变更事件，发送至 MQ。
    3.  **消费端局部更新**：消费端逻辑与标准 CDC 完全一致，动态构建 ES `UpdateRequest`。
- **回答质疑：“为什么不用 Canal？”**
    - “因为现阶段引入 Canal 会增加运维复杂度。但我设计的这套 **Event Schema** 是完全兼容 Canal 格式的。未来业务量级突破后，只需将 AOP 拦截器替换为 Canal 监听，消费端代码**无需任何修改**即可无缝切换到底层 Binlog 同步。”

## Result (结果与收益)
- **性能提升**：在“修改价格”等高频小字段变更场景下，同步链路的网络吞吐量降低了 **70%**。
- **稳定性增强**：彻底消除了业务层面的并发冲突风险。
- **前瞻性设计**：通过**应用层 CDC** 实现了低成本落地，同时保留了向**架构层 CDC** 平滑演进的能力，体现了架构设计的**演进式思维 (Evolutionary Architecture)**。


## Appendix (技术原理解析)
- **1. Binlog (Binary Log)**
    - MySQL 的“黑匣子”，记录了所有对数据库数据的修改操作（Insert/Update/Delete）。
    - **Row 模式**：Binlog 的一种记录格式（推荐）。它不记录 SQL 语句，而是记录每一行数据**物理变更**的细节。
- **2. Before / After Image (镜像)**
    - 在 Row 模式下，一次 Update 操作会记录两个状态：
        - **Before Image**：修改**前**，这一行所有字段的值。
        - **After Image**：修改**后**，这一行所有字段的值。
    - **Diff 计算**：CDC 的核心就是对比这两份镜像，精准找出变了哪个字段（例如：
ame 没变，price 变了）。
- **3. Canal 原理**
    - **伪装**：Canal 启动后，向 MySQL Master 发送 Dump 协议，假装自己是一个 MySQL Slave（从库）。
    - **推送**：MySQL 收到请求，就会把 Binlog 推送给 Canal。
    - **解析**：Canal 将二进制的 Binlog 解析为 JSON 格式的变更事件，供下游消费。


## 6. 架构洞察：ES 作为 MySQL 的“超级覆盖索引” (Covering Index Analogy)
- **核心比喻**：
    - 在传统的数据库调优中，**覆盖索引 (Covering Index)** 指的是索引字段包含了查询所需的所有数据，从而避免了“回表”查询。
    - 在分布式微服务架构中，**Elasticsearch (窄表设计)** 实际上充当了 **MySQL 的“全局分布式覆盖索引”**。
- **窄字段设计的深度思考**：
    - **现状**：我们的 ES 索引并没有存储课程的所有字段（如富文本详情），仅存储了搜索、过滤、排序和列表页展示所需的 10% 核心字段。
    - **收益 (避免“回表”)**：
        1.  **列表页展示**：当用户搜索课程时，ES 直接返回标题、封面、价格等字段。前端直接渲染列表，**0 次回源 MySQL**。这相当于“索引覆盖”，效率极高。
        2.  **详情页回源**：只有当用户点击具体课程进入详情页时，系统才带着 ID 去 MySQL (或 Redis) 获取那 90% 的非索引字段（如 HTML 详情）。
- **总结**：这种“窄表”设计不仅降低了同步的带宽成本（CDC 只需同步 10% 的变更），更利用了“覆盖索引”的思想，极大提升了 C 端高频搜索场景的响应速度，实现了架构层面的读写分离与动静分离。
