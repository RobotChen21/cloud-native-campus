# 面试话术：设计模式与 OOP 原则在项目中的实战

## 💡 核心逻辑
**OOP 七大原则（道） -> 三大分类（法） -> Spring 源码印证（师） -> 个人项目实战（术）**

---

## 🗣️ 回答话术模板

### 1. 开场：从原则切入（展示深度）
“面试官您好，关于设计模式，我认为不能死记硬背。本质上，**设计模式是 OOP 七大设计原则的具体实现手段**。

特别是**开闭原则（Open/Closed Principle）**和**单一职责原则（SRP）**。我们在写代码时，最核心的目标就是**解耦**——让代码对扩展开放，对修改关闭。这样当需求变更时，我们只需要新增类，而不需要去改动原本运行稳定的核心代码，从而降低系统风险。”

### 2. 过渡：简述体系与框架应用（展示广度）
“我们知道设计模式主要分为三大类：**创建型**（如工厂、单例）、**结构型**（如代理、适配器）和**行为型**（如策略、模板）。

其实在我们的日常开发中，**Spring 框架**本身就是设计模式的集大成者：
*   **单例模式**：Spring Bean 默认就是单例的。
*   **工厂模式**：`BeanFactory` 和 `ApplicationContext` 是典型的工厂实现。
*   **模板模式**：像 `RedisTemplate`、`JdbcTemplate`，它帮我们封装了连接获取、释放等固定流程，我们只需要关注核心业务。
*   **代理模式**：Spring AOP 的底层（JDK 动态代理或 CGLIB）就是代理模式的体现。”

### 3. 高潮：项目实战案例（展示能力）
“**以我最近参与的‘天机学堂’项目为例**，我在负责**营销促销模块（Promotion）**时，就通过组合多种设计模式，重构了**分布式锁**的实现。

**【背景与痛点】**
当时我们的业务涉及很多并发场景（如抢券、抽奖），需要频繁使用 Redisson 加锁。起初代码里充斥着大量的重复逻辑：
1.  Try-Catch-Finally 样板代码。
2.  大量的 `if-else` 判断：有的场景需要快速失败，有的需要死等，有的需要超时重试。
3.  有的场景需要公平锁，有的需要读写锁。
这导致业务代码非常臃肿，且违反了**单一职责原则**。

**【解决方案：组合拳】**
为了解决这个问题，我设计了一套基于注解的分布式锁组件：

**第一步：策略模式 (Strategy Pattern) —— 解决‘怎么锁’**
我定义了一个 `MyLockStrategy` 枚举，实现了策略模式。
*   我把‘快速失败’、‘无限重试’、‘超时重试’等不同的锁行为，封装成了不同的策略实现。
*   **好处**：这完美契合了**开闭原则**。如果未来需要新增一种‘指数退避重试’的策略，我只需要在枚举里加一个实现，完全不用去改动现有的业务代码。

**第二步：简单工厂模式 (Simple Factory) —— 解决‘锁对象怎么来’**
我创建了一个 `MyLockFactory`。
*   它负责根据传入的类型（Reentrant、Fair、Read/Write），从 RedissonClient 中生产出对应的 `RLock` 对象。
*   **好处**：业务层不需要关心底层是 Redisson 还是其他实现，也不用关心锁的具体创建细节。

**第三步：代理模式 (Proxy/AOP) —— 统一收口**
最后，我利用 **Spring AOP（动态代理）** + **自定义注解 `@MyLock`**。
*   利用 SPEL 表达式动态解析参数（如 `#userId`）实现细粒度加锁。
*   在切面中，通过工厂获取锁对象，通过策略执行加锁逻辑。

> **💡 进阶细节补充：模板方法与事务陷阱**
>
> 这里其实还隐含了**模板方法模式 (Template Method)** 的思想。
> “加锁 -> 执行业务 -> 解锁”是一套固定的骨架，具体的业务逻辑（`pjp.proceed()`）是可变的。我通过 AOP 拦截器实现了这个“模板”，业务开发人员只需要写核心逻辑。
>
> 此外，在实现时我遇到了一个**分布式锁与事务优先级**的经典坑。
> 如果 `@Transactional` 和 `@MyLock` 同时存在，必须保证 **锁的范围 > 事务的范围**。
> 否则会出现“锁已释放，但事务还没提交”的空窗期，导致并发事故。
> **解决方案**：我让切面实现了 `Ordered` 接口，并将 `order` 设为 `0`（最高优先级），确保切面包裹在 Spring 事务切面（默认最低优先级）的外层。

**【最终收益】**
经过这样重构，业务同事在写代码时，只需要一行 `@MyLock(name="key", strategy=FAIL_FAST)`，业务代码从十几行缩减为一行，不仅逻辑解耦，而且彻底杜绝了‘忘记释放锁’导致的线上事故。”

---

## 📝 总结 Key Points
1.  **OOP 原则**：强调解耦、开闭原则。
2.  **Spring 举例**：Template、Proxy，证明你懂框架原理。
3.  **自身案例**：
    *   **策略模式**：消灭 if-else，封装锁的等待逻辑。
    *   **工厂模式**：隐藏 Redisson 锁的创建细节。
    *   **AOP/代理**：分离业务逻辑与非业务逻辑（加锁）。
    *   **细节亮点**：模板方法思想 + AOP Order 解决事务一致性问题。