### 第一部分：简历如何包装 (Resume Packaging)

在简历的项目经验或个人技能部分，不要只写“实现了点赞功能”。要用**“STAR原则”**（情境、任务、行动、结果）强调**高并发**、**性能优化**和**架构思考**。

**推荐写法（根据你的级别选一条）：**

> **写法 A（侧重架构设计 & 性能优化 - 推荐）：**
>
> - **重构点赞互动核心模块**：针对传统 MySQL 方案在 Feed 流场景下的读写瓶颈，设计了基于 **Redis + MQ + MySQL** 的多级读写分离架构。
> - **解决核心痛点**：通过**维度解耦**（计数看热度、状态看时间线），解决了百万级热点内容的 **BigKey 问题**；利用 **MQ 削峰填谷**，支撑起万级 QPS 的瞬间写入冲击。
> - **极致性能优化**：引入**冷热分离策略**，Feed 流查询延迟从 200ms+ 降低至 **10ms** 级别；设计布隆过滤器兜底方案，有效防止冷数据回源导致的缓存穿透。

> **写法 B（侧重具体技术落地）：**
>
> - 负责互动中台建设，主导点赞功能的**去 BigKey 化改造**。
> - 摒弃全量 Redis Set 方案，采用 **Redis ZSet (Timeline)** 存储用户近况，结合 **Local Buffer 聚合写入**策略，大幅降低 Redis 内存占用（节省 90%）与网络 IO 开销。
> - 设计了基于**最终一致性**的兜底容错机制，确保在 Redis 宕机或消息丢失极端场景下的数据可靠性。

------

### 第二部分：面试讲解思路 (The Narrative)

当面试官问：“**请介绍一下你做的点赞功能**”或者“**这里有什么难点**”时，千万不要上来就背代码。

你要像讲故事一样，按照 **V1 (痛点) -> V2 (解决) -> V3 (完善)** 的逻辑娓娓道来。

#### 话术模板：

**1. 开场（抛出业务场景与痛点）：**

> “这个功能看似简单，但在我们的业务场景下（Feed 流、高并发），面临两个核心挑战：
>
> 第一是**Feed 流的高频查询**，如果查库，数据库根本扛不住；
>
> 第二是**热门内容的瞬间写入**，比如爆款视频可能会有百万级并发，直接写库会导致宕机。”

**2. 核心设计（展示维度解耦的智慧）：**

> “为了解决这两个问题，我并没有用一套数据结构死磕，而是把点赞拆成了两个维度：
>
> - **对内容（视频）**：我们只关心‘总数’。我用了 Redis String 计数，配合本地聚合写，解决了写压力。
> - **对用户（我赞了谁）**：我们只关心‘当前 Feed 流里的状态’。我用了 Redis ZSet 存用户最近的点赞记录（Timeline）。”

**3. 突出亮点（BigKey 与 性能）：**

> “传统的做法是把所有人存到 Set 里，这会产生 BigKey。我的方案是**只存用户最近的数据（如最近 1000 条）在 Redis**。
>
> 这样在刷 Feed 流时，我只需要把用户的点赞列表拉到内存里，和当前页面的 20 个视频 ID 做比对，**完全避免了循环查 Redis**，网络开销极低。”

**4. 兜底（展示思维严谨性）：**

> “当然，这也带来了冷热数据一致性的问题。对于很久以前的冷数据，Redis 里被淘汰了。我们综合权衡后，结合布隆过滤器/回源策略（根据你的选择说），在保障 99% 体验的同时，兜底了数据的准确性。”

------

### 第三部分：面试官可能的追问 (Q&A Drill)

面试官一定会试图攻击你的方案，你要准备好“盾牌”。

#### Q1: “你只存最近 1000 条，那用户滑到一年前的视频，看到自己‘未点赞’，结果点赞时提示‘重复点赞’，怎么办？”

- **考察点**：边界情况处理、一致性。
- **回答**：
  - **业务层**：首先，Feed 流绝大多数是推新内容，命中冷数据的概率极低。
  - **技术层**：如果真的发生了，后端接口做了**幂等性校验**。
  - **补救**：当 MySQL 报错“重复主键”时，接口不报错，而是直接返回“成功”，并且**异步把这条冷数据重新“加热”回 Redis**。这样前端图标立刻变亮，用户体验是无感知的。

#### Q2: “MQ 消息如果丢了怎么办？数据不就永远不一致了吗？”

- **考察点**：可靠性设计。
- **回答**：
  - **防线一**：MQ 开启持久化和 ACK 机制，保证至少投递一次。
  - **防线二（大招）**：我们有一个**T+1 的对账脚本**（或定期校正机制）。利用 Redis 里的热点计数值，和数据库里的 `Count(*)` 做比对，如果偏差过大，触发自动修复。
  - **心态**：在超高并发场景下，我们追求的是**最终一致性**，允许短时间的数值偏差，但关键的用户关系数据（MySQL）是有唯一索引兜底的，绝对不会错。

#### Q3: “Redis 挂了怎么办？”

- **考察点**：高可用、降级。
- **回答**：
  - **读降级**：如果是点赞数，挂了就挂了，前端展示“10w+”或者暂不展示，不影响核心流程；如果是状态，可以临时降级为“未点赞”或查布隆过滤器。
  - **写降级**：如果 Redis 写失败，我们直接降级写入 MQ，由消费者慢慢写入数据库。只要 MQ 不挂，数据就不会丢。

#### Q4: “为什么不直接用 MySQL 分库分表抗写入？”

- **考察点**：对数据库性能瓶颈的理解。
- **回答**：
  - MySQL 分库分表确实能提升吞吐，但面对**突发热点**（比如某个明星突然发视频，流量集中在几秒内），数据库的磁盘 IO 依然是瓶颈。
  - Redis 是内存操作，且支持**本地聚合（Local Buffer）**，比如攒够 100 个赞才发一次 Redis 命令，这把写压力降低了几个数量级，是 MySQL 做不到的。

------

### 第四部分：加分项（杀手锏）

如果在面试结束前，你能主动抛出以下观点，会非常加分：

1. **关于未来的扩展**：“如果这套系统演进到抖音那种体量，MySQL 的 B+ 树可能就不行了，我会考虑迁移到 **TiKV** 或 **HBase** 这种基于 **LSM-Tree** 的数据库，利用其顺序写特性来抗更高的并发。”
2. **关于成本**：“我这套方案最大的优势其实是**省钱**。相比于存储全量关系的 Redis 方案，我们只存热数据，内存节省了 90%，这对于公司来说是实打实的成本优化。”

这一套组合拳打下来，面试官不仅会觉得你技术过硬，还会觉得你有**成本意识**和**架构演进的全局观**。祝你面试顺利！